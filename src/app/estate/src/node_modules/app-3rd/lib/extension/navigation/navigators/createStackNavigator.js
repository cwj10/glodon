import React from 'react'
import { NoMatch, Switch, Route, Link } from 'react-router'
import { View, Text, TouchableOpacity, TextInput, SafeAreaView, StyleSheet, Platform } from 'react-native'

import { goBack, replace } from 'connected-react-router';
import Header from "./../views/Header/Header";
import TransitionConfigs from './../views/StackView/StackViewTransitionConfigs';
import { SCENE_KEYS, SCENES, SceneActions } from "./SceneActions"

function createStackNavigator(screens, configure) {
    function createStackView(Screen, configure, eventHandler) {
        const Navigator = {
            state: {
                params: {}
            },
            getParam: () => { },
            setParams: () => { },
            navigator: {},

            dispatch: (action) => {
                SceneActions.dispatch(screens, action, eventHandler);
            },
            goBack: (payload) => {
               let action =  SceneActions.back(payload);
               SceneActions.dispatch(screens, action, eventHandler);
            },
            pop: (payload) => {
                let action =  SceneActions.pop(payload, eventHandler);
                SceneActions.dispatch(screens, action, eventHandler);
            },
            replace: (routeName, params) => {
                let action =  SceneActions.replace({ 'routeName': routeName, 'params': params });
                SceneActions.dispatch(screens, action, eventHandler);
            },
            navigate: (routeName, params) => {
                let action =  SceneActions.navigate({ 'routeName': routeName, 'params': params });
                SceneActions.dispatch(screens, action, eventHandler);
            },
        };

        class StackView extends React.Component {
            constructor(props) {
                super(props)
                if (this.props.params) {
                    Navigator.state.params = this.props.params;
                }
            }
            _getHeaderMode() {
                if (this.props.headerMode) {
                    return this.props.headerMode;
                }
                if (Platform.OS === 'android' || this.props.mode === 'modal') {
                    return 'screen';
                }
                return 'float';
            }

            _getHeaderTransitionPreset() {
                // On Android or with header mode screen, we always just use in-place,
                // we ignore the option entirely (at least until we have other presets)
                if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {
                    return 'fade-in-place';
                }

                // TODO: validations: 'fade-in-place' or 'uikit' are valid
                if (this.props.headerTransitionPreset) {
                    return this.props.headerTransitionPreset;
                } else {
                    return 'fade-in-place';
                }
            }
            _renderHeader(scene = { descriptor: { options: { title: 'title', headerBackground: '#00b3a5' } } }, headerMode) {
                const { options } = scene.descriptor;
                const { header } = options;

                if (header === null && headerMode === 'screen') {
                    return null;
                }

                // check if it's a react element
                if (React.isValidElement(header)) {
                    return header;
                }

                // Handle the case where the header option is a function, and provide the default
                const renderHeader = (props => <Header {...props} />);

                const {
                  headerLeftInterpolator,
                  headerTitleInterpolator,
                  headerRightInterpolator,
                } = this._getTransitionConfig();

                const {
                    mode,
                    transitionProps,
                    prevTransitionProps,
                    ...passProps
                } = this.props;

                return renderHeader({
                    mode,
                    transitionProps,
                    prevTransitionProps,
                    ...passProps
                });
            }
            _getTransitionConfig = () => {
                const isModal = this.props.mode === 'modal';
            
                return TransitionConfigs.getTransitionConfig(
                  this.props.transitionConfig,
                  this.props.transitionProps,
                  this.props.prevTransitionProps,
                  isModal
                );
              };

            render = () => {
                return (
                    <View style={{ width: '100%', height: '100%' }}>
                        {this._renderHeader()}
                        <Screen navigation={Navigator}></Screen>
                    </View>)
            }
        }
        return StackView;
    }
    updateStackRouter = null;

    class StackRouter extends React.Component {
        updateIndex = 0;
        constructor(props) {
            super(props);
            SceneActions.clear();
            if (configure.initialRouteName) {
                let initScreenData = screens[configure.initialRouteName];
                SCENE_KEYS.push({ key: configure.initialRouteName, scene: initScreenData.screen });
            }
            this.state = {
                params: {},
            }
        }
        eventHandler = (params) => {
            params = params ? params : {};
            this.setState({
                updateIndex: this.updateIndex++,
                params: params,
            })
        }

        renderCard(scene, index, params = {}) {
            if (SCENES.has(scene.key)) {
                return SCENES.get(scene.key);
            }
            let Page = createStackView(scene.scene, this.props, this.eventHandler)
            let card = (
                <View style={styles.cardContainer} key={'' + index}>
                    <Page key={index} params={params} />
                </View>
            )
            SCENES.set(scene.key, card)
            return card;
        }

        render = () => {
            return (
                <SafeAreaView >
                    <View style={styles.sceneContainer} >
                        {
                            SCENE_KEYS.map((scene, index) => {
                                return this.renderCard(scene, index, this.state.params)
                            })
                        }
                    </View>
                </SafeAreaView>
            )
        }
    }

    return StackRouter;
}
const styles = StyleSheet.create({
    sceneContainer: {
        width: "100%",
        height: "100%"
    },
    cardContainer: {
        width: "100%",
        height: "100%",
        position: "absolute",
    }
})

export default createStackNavigator;