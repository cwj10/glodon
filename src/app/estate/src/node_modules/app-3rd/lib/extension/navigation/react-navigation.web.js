import React from 'react'
import { NoMatch, Switch, Route, Link } from 'react-router'
import { View, Text, TouchableOpacity, TextInput, SafeAreaView, StyleSheet, Platform } from 'react-native'
// third lib
import { NavigationActions, StackActions } from './../../react-navigation/src/react-navigation'
import { goBack, replace } from 'connected-react-router';
import Header from "./views/Header/Header";
import { SCENE_KEYS, SCENES, SceneActions } from "./SceneActions"

export function createStackNavigator(screens, configure) {
    function createStackView(Screen, configure) {
        const Navigator = {
            state: {
                params: {}
            },
            getParam: () => { },
            setParams: () => { },
            navigator: {},

            dispatch: (action) => {
                SceneActions.dispatch(screens, action);
            },
            goBack: (payload) => {
                SceneActions.back(screens, payload);
            },
            pop: (payload) => {
                SceneActions.pop(screens, payload);
            },
            replace: (routeName, params) => {
                SceneActions.replace(screens, { 'routeName': routeName, 'params': params});
            },
            navigate: (routeName, params) => {
                SceneActions.navigate(screens, { 'routeName': routeName, 'params': params });
            },
        };

        class StackView extends React.Component {
            constructor(props) {
                super(props)
                if (this.props.params) {
                    Navigator.state.params = this.props.params;
                }
            }
            _getHeaderMode() {
                if (this.props.headerMode) {
                  return this.props.headerMode;
                }
                if (Platform.OS === 'android' || this.props.mode === 'modal') {
                  return 'screen';
                }
                return 'float';
              }
  
            _getHeaderTransitionPreset() {
                // On Android or with header mode screen, we always just use in-place,
                // we ignore the option entirely (at least until we have other presets)
                if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {
                  return 'fade-in-place';
                }
            
                // TODO: validations: 'fade-in-place' or 'uikit' are valid
                if (this.props.headerTransitionPreset) {
                  return this.props.headerTransitionPreset;
                } else {
                  return 'fade-in-place';
                }
              }
              _renderHeader(scene = {descriptor:{options:{title:'title',headerBackground:'#00b3a5'}}}, headerMode) {
                const { options } = scene.descriptor;
                const { header } = options;
            
                if (header === null && headerMode === 'screen') {
                  return null;
                }
            
                // check if it's a react element
                if (React.isValidElement(header)) {
                  return header;
                }
            
                // Handle the case where the header option is a function, and provide the default
                const renderHeader = (props => <Header {...props} />);
            
                // const {
                //   headerLeftInterpolator,
                //   headerTitleInterpolator,
                //   headerRightInterpolator,
                // } = this._getTransitionConfig();
            
                const {
                  mode,
                  transitionProps,
                  prevTransitionProps,
                  ...passProps
                } = this.props;
            
                return renderHeader({mode,
                    transitionProps,
                    prevTransitionProps,
                    ...passProps
                });
              }
            render = () => {
                return (
                    <View style={{ width: '100%', height: '100%' }}>
                        {this._renderHeader()}
                        <Screen navigation={Navigator}></Screen>
                    </View>)
            }
        }
        return StackView;
    }
    updateStackRouter = null;

    class StackRouter extends React.Component {
        updateIndex = 0;
        constructor(props) {
            super(props);
            SceneActions.clear();
            if (configure.initialRouteName) {
                let initScreenData = screens[configure.initialRouteName];
                SCENE_KEYS.push({ key: configure.initialRouteName, scene: initScreenData.screen });
            }
            
            SceneActions.setUpdateCallback(this.updateStackRouter)
            this.state = {
                params: {},
            }
        }

        updateStackRouter = (params) => {
            params = params ? params : {};
            this.setState({
                updateIndex: this.updateIndex++,
                params: params,
            })
        }

        renderCard(scene, index, params = {}) {
            if (SCENES.has(scene.key)) {
                return SCENES.get(scene.key);
            }
            let Page = createStackView(scene.scene, this.props)
            let card = (
                <View style={styles.cardContainer} key={'' + index}>
                    <Page key={index} params={params} />
                </View>
            )
            SCENES.set(scene.key, card)
            return card;
        }

        render = () => {
            return (
                <SafeAreaView >
                    <View style={styles.sceneContainer} >
                        {
                            SCENE_KEYS.map((scene, index) => {
                                return this.renderCard(scene, index, this.state.params)
                            })
                        }
                    </View>
                </SafeAreaView>
            )
        }
    }

    return StackRouter;
}
const styles = StyleSheet.create({
    sceneContainer: {
        width: "100%",
        height: "100%"
    },
    cardContainer: {
        width: "100%",
        height: "100%",
        position: "absolute",
    }
})

export { NavigationActions, StackActions }
