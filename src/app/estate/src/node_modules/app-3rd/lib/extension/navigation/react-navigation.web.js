import React from 'react'
import { NoMatch, Switch, Route, Link } from 'react-router'
import { View, Text, TouchableOpacity, TextInput, SafeAreaView, Platform } from 'react-native'
// third lib
import { NavigationActions, StackActions } from './../../react-navigation/src/react-navigation'
import { goBack, replace } from 'connected-react-router';
import { WebStackActions } from './../WebStackActions';
import Header from "./views/Header/Header";
const aboutCount = 0;

export function createStackNavigator(screens, configure) {

    const scenes = [];
    function createStackView(Screen, configure) {
        let history = configure.history;
        const Navigator = {
            state: {
                params: {}
            },
            getParam: () => { },
            setParams: () => { },
            navigator: {},

            dispatch: (action) => {
                WebStackActions.dispatch(history, action);
            },
            goBack: (payload) => {
                let action = WebStackActions.back(payload);
                WebStackActions.dispatch(history, action);
            },
            pop: (payload) => {
                let action = WebStackActions.pop(payload);
                WebStackActions.dispatch(history, action);
            },
            replace: (routeName, params) => {
                let action = WebStackActions.replace({ 'routeName': routeName, 'params': params });
                WebStackActions.dispatch(history, action);
            },
            navigate: (routeName, params) => {
                let action = WebStackActions.navigate({ 'routeName': routeName, 'params': params });
                WebStackActions.dispatch(history, action);
            },
        };
        class StackView extends React.Component {
            constructor(props) {
                super(props)
                this.state = {
                    inputValue: "sss"
                }
            }
            _getHeaderMode() {
                if (this.props.headerMode) {
                  return this.props.headerMode;
                }
                if (Platform.OS === 'android' || this.props.mode === 'modal') {
                  return 'screen';
                }
                return 'float';
              }
  
            _getHeaderTransitionPreset() {
                // On Android or with header mode screen, we always just use in-place,
                // we ignore the option entirely (at least until we have other presets)
                if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {
                  return 'fade-in-place';
                }
            
                // TODO: validations: 'fade-in-place' or 'uikit' are valid
                if (this.props.headerTransitionPreset) {
                  return this.props.headerTransitionPreset;
                } else {
                  return 'fade-in-place';
                }
              }
              _renderHeader(scene = null, headerMode) {
                // const { options } = scene.descriptor;
                // const { header } = options;
            
                // if (header === null && headerMode === 'screen') {
                //   return null;
                // }
            
                // check if it's a react element
                // if (React.isValidElement(header)) {
                //   return header;
                // }
            
                // Handle the case where the header option is a function, and provide the default
                const renderHeader = (props => <Header {...props} />);
            
                // const {
                //   headerLeftInterpolator,
                //   headerTitleInterpolator,
                //   headerRightInterpolator,
                // } = this._getTransitionConfig();
            
                const {
                  mode,
                  transitionProps,
                  prevTransitionProps,
                  ...passProps
                } = this.props;
            
                return renderHeader({
                });
              }
            render = () => {
                return (
                    <View style={{ width: '100%', height: '100%' }}>
                        {this._renderHeader()}
                        <Screen></Screen>
                    </View>)
            }
        }
        return StackView;
    }

    class StackRouter1 extends React.Component {
        render = () => {
            let initScreen = null;
            if (configure.initialRouteName) {
                let initScreenData = screens[configure.initialRouteName];
                initScreen = <Route path={'/'} exact component={createStackView(initScreenData.screen, this.props)} />
            }
            let arrayData = [];
            for (var key in screens) {
                arrayData.push({ key: key, item: screens[key] });
            }
            return (<Switch>
                {initScreen}
                {
                    arrayData.map((item, index) => {
                        return <Route key={item + '-' + index} path={'/' + item.key} exact component={createStackView(item.item.screen, this.props)} />
                    })}
                <Route component={NoMatch} />
            </Switch>)
        }
    }

    class StackRouter extends React.Component {
        render = () => {
            if (configure.initialRouteName) {
                let initScreenData = screens[configure.initialRouteName];
                scenes.push(initScreenData.screen);
            }
            return (
                <SafeAreaView >
                    <View style={{ width: "100%", height: "100%" }} >
                        {
                            scenes.map((scene, index) => {
                                let Page = createStackView(scene, this.props)
                                return (
                                    <Page key={index} />
                                )
                            })
                        }
                    </View>
                </SafeAreaView>
            )
        }
    }

    return StackRouter;
}

export { NavigationActions, StackActions }
