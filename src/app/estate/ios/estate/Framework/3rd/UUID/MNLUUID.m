//
//  MNLUUID.m
//  meinvli8
//
//  Created by soul on 14-6-6.
//  Copyright (c) 2017å¹´ soul. All rights reserved.
//
#import <sys/socket.h> // Per msqr
#import <sys/sysctl.h>
#import <net/if.h>
#import <net/if_dl.h>
#import <AdSupport/AdSupport.h>
#import "MNLUUID.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/sockio.h>
#include <net/if.h>
#include <errno.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <ifaddrs.h>
#import <dlfcn.h>
#import <SystemConfiguration/SystemConfiguration.h>
#include <net/ethernet.h>
#import <UIKit/UIKit.h>

#define min(a,b)    ((a) < (b) ? (a) : (b))
#define max(a,b)    ((a) > (b) ? (a) : (b))

#define BUFFERSIZE  4000
#define MAXADDRS 256
char *if_names[MAXADDRS];
char *ip_names[MAXADDRS];
char *hw_addrs[MAXADDRS];
unsigned long ip_addrs[MAXADDRS];

static int   nextAddr = 0;

void InitAddresses()
{
    int i;
    for (i=0; i<MAXADDRS; ++i)
    {
        if_names[i] = ip_names[i] = hw_addrs[i] = NULL;
        ip_addrs[i] = 0;
    }
}

void FreeAddresses()
{
    int i;
    for (i=0; i<MAXADDRS; ++i)
    {
        if (if_names[i] != 0) free(if_names[i]);
        if (ip_names[i] != 0) free(ip_names[i]);
        if (hw_addrs[i] != 0) free(hw_addrs[i]);
        ip_addrs[i] = 0;
    }
    InitAddresses();
}

void GetIPAddresses()
{
    int                 i, len, flags;
    char                buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;
    struct ifconf       ifc;
    struct ifreq        *ifr, ifrcopy;
    struct sockaddr_in  *sin;
    
    char temp[80];
    
    int sockfd;
    
    for (i=0; i<MAXADDRS; ++i)
    {
        if_names[i] = ip_names[i] = NULL;
        ip_addrs[i] = 0;
    }
    
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket failed");
        return;
    }
    
    ifc.ifc_len = BUFFERSIZE;
    ifc.ifc_buf = buffer;
    
    if (ioctl(sockfd, SIOCGIFCONF, &ifc) < 0)
    {
        perror("ioctl error");
        return;
    }
    
    lastname[0] = 0;
    
    for (ptr = buffer; ptr < buffer + ifc.ifc_len; )
    {
        ifr = (struct ifreq *)ptr;
        len = max(sizeof(struct sockaddr), ifr->ifr_addr.sa_len);
        ptr += sizeof(ifr->ifr_name) + len;  // for next one in buffer
        
        if (ifr->ifr_addr.sa_family != AF_INET)
        {
            continue;   // ignore if not desired address family
        }
        
        if ((cptr = (char *)strchr(ifr->ifr_name, ':')) != NULL)
        {
            *cptr = 0;      // replace colon will null
        }
        
        if (strncmp(lastname, ifr->ifr_name, IFNAMSIZ) == 0)
        {
            continue;   /* already processed this interface */
        }
        
        memcpy(lastname, ifr->ifr_name, IFNAMSIZ);
        
        ifrcopy = *ifr;
        ioctl(sockfd, SIOCGIFFLAGS, &ifrcopy);
        flags = ifrcopy.ifr_flags;
        if ((flags & IFF_UP) == 0)
        {
            continue;   // ignore if interface not up
        }
        
        if_names[nextAddr] = (char *)malloc(strlen(ifr->ifr_name)+1);
        if (if_names[nextAddr] == NULL)
        {
            return;
        }
        strcpy(if_names[nextAddr], ifr->ifr_name);
        
        sin = (struct sockaddr_in *)&ifr->ifr_addr;
        strcpy(temp, inet_ntoa(sin->sin_addr));
        
        ip_names[nextAddr] = (char *)malloc(strlen(temp)+1);
        if (ip_names[nextAddr] == NULL)
        {
            return;
        }
        strcpy(ip_names[nextAddr], temp);
        
        ip_addrs[nextAddr] = sin->sin_addr.s_addr;
        
        ++nextAddr;
    }
    
    close(sockfd);
}

void GetHWAddresses()
{
    struct ifconf ifc;
    struct ifreq *ifr;
    int i, sockfd;
    char buffer[BUFFERSIZE], *cp, *cplim;
    char temp[80];
    
    for (i=0; i<MAXADDRS; ++i)
    {
        hw_addrs[i] = NULL;
    }
    
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket failed");
        return;
    }
    
    ifc.ifc_len = BUFFERSIZE;
    ifc.ifc_buf = buffer;
    
    if (ioctl(sockfd, SIOCGIFCONF, (char *)&ifc) < 0)
    {
        perror("ioctl error");
        close(sockfd);
        return;
    }
    
//    ifr = ifc.ifc_req;
    
    cplim = buffer + ifc.ifc_len;
    
    for (cp=buffer; cp < cplim; )
    {
        ifr = (struct ifreq *)cp;
        if (ifr->ifr_addr.sa_family == AF_LINK)
        {
            struct sockaddr_dl *sdl = (struct sockaddr_dl *)&ifr->ifr_addr;
            int a,b,c,d,e,f;
            int i;
            
            strcpy(temp, (char *)ether_ntoa((void *)LLADDR(sdl)));
            sscanf(temp, "%x:%x:%x:%x:%x:%x", &a, &b, &c, &d, &e, &f);
            sprintf(temp, "%02X:%02X:%02X:%02X:%02X:%02X",a,b,c,d,e,f);
            
            for (i=0; i<MAXADDRS; ++i)
            {
                if ((if_names[i] != NULL) && (strcmp(ifr->ifr_name, if_names[i]) == 0))
                {
                    if (hw_addrs[i] == NULL)
                    {
                        hw_addrs[i] = (char *)malloc(strlen(temp)+1);
                        strcpy(hw_addrs[i], temp);
                        break;
                    }
                }
            }
        }
        cp += sizeof(ifr->ifr_name) + max(sizeof(ifr->ifr_addr), ifr->ifr_addr.sa_len);
    }
    
    close(sockfd);
}
@implementation MNLUUID
- (NSString *) whatismyipdotcom
{
    NSError *error;
    NSURL *ipURL = [NSURL URLWithString:@"http://www.whatismyip.com/automation/n09230945.asp"];
    NSString *ip = [NSString stringWithContentsOfURL:ipURL encoding:1 error:&error];
    return ip ? ip : [error localizedDescription];
}
+ (NSString *) localWiFiIPAddress
{
    BOOL success;
    struct ifaddrs * addrs;
    const struct ifaddrs * cursor;
    
    success = getifaddrs(&addrs) == 0;
    if (success) {
        cursor = addrs;
        while (cursor != NULL) {
            // the second test keeps from picking up the loopback address
            if (cursor->ifa_addr->sa_family == AF_INET && (cursor->ifa_flags & IFF_LOOPBACK) == 0)
            {
                NSString *name = [NSString stringWithUTF8String:cursor->ifa_name];
                if ([name isEqualToString:@"en0"])  // Wi-Fi adapter
                    return [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)cursor->ifa_addr)->sin_addr)];
            }
            cursor = cursor->ifa_next;
        }
        freeifaddrs(addrs);
    }
    return nil;
}
// 1.open uuid
// 2.mac address
#pragma mark MAC addy
//Return the local MAC addy
//Courtesy of FreeBSD hackers email list
//Accidentally munged during previous update. Fixed thanks to mlamb.
+ (NSString *) macaddress{
    
    int                 mib[6];
    size_t              len;
    char                *buf;
    unsigned char       *ptr;
    struct if_msghdr    *ifm;
    struct sockaddr_dl  *sdl;
    
    mib[0] = CTL_NET;
    mib[1] = AF_ROUTE;
    mib[2] = 0;
    mib[3] = AF_LINK;
    mib[4] = NET_RT_IFLIST;
    
    if ((mib[5] = if_nametoindex("en0")) == 0) {
        printf("Error: if_nametoindex errorn");
        return NULL;
    }
    
    if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 1n");
        return NULL;
    }
    
    if ((buf = malloc(len)) == NULL) {
        printf("Could not allocate memory. error!n");
        return NULL;
    }
    
    if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 2");
        free(buf);
        return NULL;
    }
    
    ifm = (struct if_msghdr *)buf;
    sdl = (struct sockaddr_dl *)(ifm + 1);
    ptr = (unsigned char *)LLADDR(sdl);
    NSString *outstring = [NSString stringWithFormat:@"%X:%X:%X:%X:%X:%X",
                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];
    free(buf);
    
    return outstring;
}
+ (NSString *)getMacAddress
{
    int                 mgmtInfoBase[6];
    char                *msgBuffer = NULL;
    size_t              length;
    unsigned char       macAddress[6];
    struct if_msghdr    *interfaceMsgStruct;
    struct sockaddr_dl  *socketStruct;
    NSString            *errorFlag = NULL;
    
    // Setup the management Information Base (mib)
    mgmtInfoBase[0] = CTL_NET;        // Request network subsystem
    mgmtInfoBase[1] = AF_ROUTE;       // Routing table info
    mgmtInfoBase[2] = 0;
    mgmtInfoBase[3] = AF_LINK;        // Request link layer information
    mgmtInfoBase[4] = NET_RT_IFLIST;  // Request all configured interfaces
    
    // With all configured interfaces requested, get handle index
    if ((mgmtInfoBase[5] = if_nametoindex("en0")) == 0)
        errorFlag = @"if_nametoindex failure";
    else
    {
        // Get the size of the data available (store in len)
        if (sysctl(mgmtInfoBase, 6, NULL, &length, NULL, 0) < 0)
            errorFlag = @"sysctl mgmtInfoBase failure";
        else
        {
            // Alloc memory based on above call
            if ((msgBuffer = malloc(length)) == NULL)
                errorFlag = @"buffer allocation failure";
            else
            {
                // Get system information, store in buffer
                if (sysctl(mgmtInfoBase, 6, msgBuffer, &length, NULL, 0) < 0)
                    errorFlag = @"sysctl msgBuffer failure";
            }
        }
    }
    
    // Befor going any further...
    if (errorFlag != NULL)
    {
        free(msgBuffer);
        NSLog(@"Error: %@", errorFlag);
        return errorFlag;
    }
    
    // Map msgbuffer to interface message structure
    interfaceMsgStruct = (struct if_msghdr *) msgBuffer;
    
    // Map to link-level socket structure
    socketStruct = (struct sockaddr_dl *) (interfaceMsgStruct + 1);
    if (socketStruct) {
        // Copy link layer address data in socket structure to an array
        memcpy(&macAddress, socketStruct->sdl_data + socketStruct->sdl_nlen, 6);
        
        // Read from char array into a string object, into traditional Mac address format
        NSString *macAddressString = [NSString stringWithFormat:@"%X:%X:%X:%X:%X:%X",
                                      macAddress[0], macAddress[1], macAddress[2],
                                      macAddress[3], macAddress[4], macAddress[5]];
        NSLog(@"Mac Address: %@", macAddressString);
        free(msgBuffer);
         return macAddressString;
    }
    
    // Release the buffer memory
    free(msgBuffer);
    
    return @"";
}
// 3.IDFA
+(NSString*)IDFA{
    return [self.class uuid];
    
}

// 5.PUSH ID
// 6.device model
+(NSString*)model{
    return [[UIDevice currentDevice] model];
}
+(NSString*)systemName{
    return [[UIDevice currentDevice] systemName];
}
+(NSString*)systemVersion{
    return [[UIDevice currentDevice] systemVersion];
}
// 7.vender(bound id)
#define IOS_VERSION_6 (([[[UIDevice currentDevice] systemVersion] floatValue] >= 6.0)? (YES):(NO))
+(NSString*)vender{
    if (IOS_VERSION_6) {
        return [[[UIDevice currentDevice] identifierForVendor] UUIDString];
    }
    return [self.class uuid];
}
// 8.system version
// 9.uuid
+(NSString*)uuid{
    
    CFUUIDRef puuid = CFUUIDCreate(nil);
    CFStringRef uuidString = CFUUIDCreateString(nil, puuid);
    NSString * result = (NSString *)CFBridgingRelease(CFStringCreateCopy(NULL, uuidString));
    CFRelease(puuid);
    CFRelease(uuidString);
    return result;
}

+ (NSString *) platform{
    
    size_t size;
    
    sysctlbyname("hw.machine", NULL, &size, NULL, 0);
    
    char *machine = malloc(size);
    
    sysctlbyname("hw.machine", machine, &size, NULL, 0);
    
    NSString *platform = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
    
    free(machine);
    
    return platform;
    
}


+ (NSString *) platformString {
  NSString *platform = [self platform];
  return [self.class platformStringInner:platform];
}

+ (NSString *) platformStringInner:(NSString*)platform {
  
  if ([platform isEqualToString:@"iPod1,1"])      return @"iPod Touch 1G";
  
  if ([platform isEqualToString:@"iPod2,1"])      return @"iPod Touch 2G";
  
  if ([platform isEqualToString:@"iPod3,1"])      return @"iPod Touch 3G";
  
  if ([platform isEqualToString:@"iPod4,1"])      return @"iPod Touch 4G";
  
  if ([platform isEqualToString:@"iPad1,1"])      return @"iPad";
  
  if ([platform isEqualToString:@"i386"] || [platform isEqualToString:@"x86_64"])         return @"iPhone Simulator";
  
  if ([platform isEqualToString:@"iPhone1,1"]) return @"iPhone 2G";
  if ([platform isEqualToString:@"iPhone1,2"]) return @"iPhone 3G";
  if ([platform isEqualToString:@"iPhone2,1"]) return @"iPhone 3GS";
  if ([platform isEqualToString:@"iPhone3,1"]) return @"iPhone 4";
  if ([platform isEqualToString:@"iPhone3,2"]) return @"iPhone 4";
  if ([platform isEqualToString:@"iPhone3,3"]) return @"iPhone 4";
  if ([platform isEqualToString:@"iPhone4,1"]) return @"iPhone 4S";
  if ([platform isEqualToString:@"iPhone5,1"]) return @"iPhone 5";
  if ([platform isEqualToString:@"iPhone5,2"]) return @"iPhone 5";
  if ([platform isEqualToString:@"iPhone5,3"]) return @"iPhone 5c";
  if ([platform isEqualToString:@"iPhone5,4"]) return @"iPhone 5c";
  if ([platform isEqualToString:@"iPhone6,1"]) return @"iPhone 5s";
  if ([platform isEqualToString:@"iPhone6,2"]) return @"iPhone 5s";
  if ([platform isEqualToString:@"iPhone7,1"]) return @"iPhone 6 Plus";
  if ([platform isEqualToString:@"iPhone7,2"]) return @"iPhone 6";
  if ([platform isEqualToString:@"iPhone8,1"]) return @"iPhone 6S";
  if ([platform isEqualToString:@"iPhone8,2"]) return @"iPhone 6S Plus";
  if ([platform isEqualToString:@"iPhone8,4"]) return @"iPhone 5SE";
  return platform;
}

@end

/*
 è¹æè®¾å¤ iphone,ipad,itouch
 
 è¿äºç§»å¨è®¾å¤é½å¯ä»¥å«ææç§»å¨è®¾å¤ï¼ä½ä¸ºä¸ä¸ªappå¼åèï¼æèæ¯ä¸ä¸ªappå¹¿åæ¨å¹¿èï¼é½æ³ç¥éæçapp,ææ¨å¹¿çadvisementæå¤å°è®¾å¤å®è£åä½¿ç¨äºã
 
 è¿å°±å¼åºäºæ³è¦ç¥éè¿ä¸ªè®¾å¤çå¯ä¸æ è¯ï¼appæ¯å®è£å¨è®¾å¤ä¸çï¼æä»¥åç¡®å®ä½è®¾å¤åæçå¾éè¦çéæ±ã
 
 å ä¸ºæ²¡å¼åè¿ ios4ä¹åçapp,æä»¥è¿éè®¨è®ºçå¹´ä»£ææ©ä»ios4å¼å§ã
 
 åä»ç»å¯ä¸æ è¯ççèå¤§å¥ã
 
 ç½å¡MACå°å
 
 0A-FC-A0-00-FD-8A
 è¿ç§12ä½è±æ°å­æ è¯ä»£è¡¨äºä¸åç½å¡çç©çå°åï¼å¨ç½ç»éè®¯å±å®æç°å®çæä¹ï¼ä¿è¯æ¯ä¸ªååè½åç¡®çåéå°å¯¹åºçç½å¡ä¸ã
 
 å¯¹äºå®è£äºç½å¡çè®¾å¤æ¥è¯´ä¹å¯ä¸æ è¯äºè¿ä¸ªè®¾å¤ï¼å®æ¯æå®¹æè¢«æ³å°æ¥åå¯ä¸æ è¯çæ°æ®ãå½ç¶å¨androidå±±å¯¨ææºä¸åä¸æ¹æ¬¡çææºç¨äºåä¸ä¸ªmacå°åçä¹å¤§å¤§å­å¨ï¼ä½æ¯éå¯¹iosç³»ç»æ¥è¯´ MAC æ çæ¯ç¢é çï¼è°å«åªæè¹æä¸å®¶åºè¹æå¢ã:) â éå²ç å°±æ¯æ²¡æwifiæ¨¡åç3gs æ²¡wifi ç½å¡ï¼åä¸å°MACå¾æ­£å¸¸
 
 å¾å¯æå¨ios 7ä¸­ ï¼å®å°ä¼è·åä¸å°ï¼æèè·åéè¯¯çä¸º 02-00-00-00-00-00, å·ä½çå¯ä»¥åç ios7çæ´æ°è¯´æã
 
 ios4 ~ ios6
 
 è®¾å¤å¯ä¸æ è¯
 
 [[UIDevice currentDevice] uniqueIdentifier]
 å¾çæçä½¿ç¨æ¹å¼ï¼ä¹æ¯æåç¡®çï¼è¿ä¸ªåæ°è¿å32ä½çè±æ°å­ä½ä¸ºè®¾å¤çå¯ä¸æ è¯ï¼ä¸ç®¡ä½ çè®¾å¤æ¯éè£ç³»ç»äºï¼è¿æ¯è¶ç±äºï¼ä¸ç®¡æ¯æ¹ææ°æ®äºï¼è¿æ¯ä¸å°å¿æäºï¼è¿åçé½æ¯ç¢é çä¸ä¸ªå¯ä¸æ è¯ ä¸åä»»ä½å¶ä»è¹æè®¾å¤çæ è¯éå¤ã
 
 ä½æ¯ï¼ä½æ¯ï¼ä½æ¯å ä¸ºå®å¤ªç¢é äºï¼æäººåè¯è¹æï¼è¿ä¸ªæ è¯æ³é²äºä¸ªäººéç§ï¼å ä¸ºå®å¤ªç²¾åå®ä½äºã
 
 æä»¥ï¼æä»¥ï¼æä»¥å®è¢«è¹æåºäºãä»ios5å¼å§ï¼å°±åºäºï¼å½ç¶å®æç»çè¢«è¹ækillæåæç»ä¸æ¶ï¼æ¯å¨ 2013å¹´åçç³æä¸­ï¼å®éæä½æ¯å¨2013å¹´4æå¼å§ï¼ææè°ç¨äºè¿ä¸ªAPIçAPPé½æ æ³ä¸æ¶ã
 
 ios2~ ios4
 
 OPENUDID
 
 å¨è¹æåºæäº uniqueIdentifierä¹åï¼èªæçå¼åèç¨èªå·±çèªæææºå¼åäºç±»uniqueIdentifierçåºï¼å®å« OpenUDID,ä¸èµè¿°äºï¼å®çæ§è½å ä¹ååè¾ uniqueIdentifierä¸è´ï¼ä¹æä»¥è¯´æ¯å ä¹ï¼æ¯å ä¸ºï¼å¦æä½ éè£os,æ¢å¤åºåè®¾ç½®ç­ç­æä½ä¹åï¼è¿ä¸ªå¼å®ä¼ååã
 
 ios2 ~ ios7
 
 åçä¾ IDFA & IDFV
 
 å¨é»æçåªè½ä½¿ç¨macåopenudidç ios5è¿å»ä¹åï¼è¹æç»äºè¯å¿åç°ï¼å®åç°ä¸è¡ï¼å¦ææ²¡æäº uniqueIdentifierå¥½å¤äºæé½å¾ä¸æ¹ä¾¿ã
 
 æä»¥ä»éæ°ç³æäº2ä¸ªAPI.
 
 IDFA
 
 å¯¹ææçå¼åèä¾åºåï¼å®é½è¿ååä¸ä¸ªå¼ï¼ä½æ¯å®æopenudidåæ ·çç¼ºç¹ï¼å®å¯è½ä¼åã
 
 åèä½¿ç¨ï¼ASIdentifierManager/advertisingIdentifier
 
 IDFV
 
 å¯¹åä¸ä¸ªå¼åèä¾åºåå¼åçææAPPs,å®è¿åçæ¯åä¸ä¸ªå¼ã å¦ææ¯å¦å¤ä¸ä¸ªå¼ååçAPPä¸­å»åè¿ä¸ªå¼è¿åçæ¯å¦å¤ä¸ä¸ªå¼ã
 
 åèä½¿ç¨ï¼UIDevice/identifierForVendor
 
 ios6 ~ ios7
 */
